SCRIPT  d:\daten\scripts\git\knop-01\krl-for-vim9\ftplugin\krl.vim
Sourced 1 time
Total time:   0.001818
 Self time:   0.001818

count  total (s)   self (s)
                            " Vim file type plugin
                            " Language: Kuka Robot Language
                            " Maintainer: Patrick Meiser-Knosowski <knosowski@graeffrobotics.de>
                            " Version: 3.0.0
                            " Last Change: 20. Apr 2022
                            "
                            " ToDo's {{{
                            " }}} ToDo's
                            
                            " Init {{{
    1              0.000007 if exists("b:did_ftplugin")
                              finish
    1              0.000001 endif
    1              0.000003 let b:did_ftplugin = 1
                            
    1              0.000005 let s:keepcpo = &cpo
    1              0.000005 set cpo&vim
                            " }}} init
                            
                            " Vim Settings {{{
                            
    1              0.000003 setlocal commentstring=;%s
    1              0.000002 setlocal comments=:;
                            
    1              0.000005 if has("fname_case")
                              setlocal suffixes+=.dat,.Dat,.DAT
                              setlocal suffixesadd+=.src,.Src,.SRC,.sub,.Sub,.SUB,.dat,.Dat,.DAT
    1              0.000001 else
    1              0.000002   setlocal suffixes+=.dat
    1              0.000002   setlocal suffixesadd+=.src,.sub,.dat
    1              0.000001 endif
    1              0.000002 let b:undo_ftplugin = "setlocal commentstring< comments< suffixes< suffixesadd<"
                            
                            " make header items, enums and sysvars a word including the characters #,$ and & 
    1              0.000007 if get(g:,'krlKeyWord',1)
    1              0.000030   setlocal iskeyword+=&,$,#
    1              0.000003   let b:undo_ftplugin .= " iskeyword<"
    1              0.000001 endif
                            
                            " auto insert comment char when i_<CR>, o or O on a comment line
    1              0.000002 if get(g:,'krlAutoComment',1)
    1              0.000002   setlocal formatoptions+=r
    1              0.000002   setlocal formatoptions+=o
    1              0.000002   let b:undo_ftplugin .= " formatoptions<"
    1              0.000001 endif
                            
                            " format comments
    1              0.000002 if get(g:,'krlFormatComments',1)
    1              0.000002   if &textwidth == 0
                                " 54 Chars do match on the teach pendant
    1              0.000003     setlocal textwidth=54
    1              0.000004     let b:undo_ftplugin .= " textwidth<"
    1              0.000001   endif
    1              0.000002   setlocal formatoptions-=t
    1              0.000001   setlocal formatoptions+=l
    1              0.000002   setlocal formatoptions+=j
    1              0.000004   if stridx(b:undo_ftplugin, " formatoptions<")==(-1)
                                " formatoptions may have already been added earlier
                                let b:undo_ftplugin .= " formatoptions<"
    1              0.000001   endif
    1              0.000001 endif " format comments
                            
                            " concealing
    1              0.000005 if has("conceal") && get(g:,'krlConcealFoldTail',1)
    1              0.000002   if &conceallevel==0
    1              0.000002     setlocal conceallevel=1
    1              0.000002     let b:undo_ftplugin .= " conceallevel<"
    1              0.000001   endif
    1              0.000000 endif
                            
                            " folding
    1              0.000003 if has("folding")
    1              0.000003   let s:krlFoldLevel = get(g:, 'krlFoldLevel', 2)
    1              0.000002   setlocal foldmethod=expr
    1              0.000002   setlocal foldtext=krl#FoldText()
    1              0.000002   setlocal foldenable
    1              0.000003   setlocal fillchars-=fold:-
    1              0.000006   execute 'setlocal foldexpr=krl#FoldExpr(v:lnum,' . s:krlFoldLevel . ')'
    1              0.000003   let b:undo_ftplugin .= " foldmethod< foldtext< foldenable< fillchars< foldexpr<"
    1              0.000705   if krl#IsVkrcFolgeOrUP()
                                execute "setlocal foldlevel=" . (2-s:krlFoldLevel)
                                let b:undo_ftplugin .= " foldlevel<"
    1              0.000001   endif
    1              0.000001 endif
                            
                            " }}} Vim Settings
                            
                            " Endwise support (tpope) {{{
    1              0.000003 if exists("loaded_endwise")
                              let b:endwise_addition  = '\=submatch(0)=~#"DEF\\>" ? "END" '
                              let b:endwise_addition .= ': submatch(0)=~#"CASE" ? "ENDSWITCH" '
                              let b:endwise_addition .= ': submatch(0)=~#"DEFAULT" ? "ENDSWITCH" '
                              let b:endwise_addition .= ': submatch(0)=~#"REPEAT" ? "UNTIL <condition>" '
                              let b:endwise_addition .= ': submatch(0)=~?"def\\>" ? "end" '
                              let b:endwise_addition .= ': submatch(0)=~?"case" ? "endswitch" '
                              let b:endwise_addition .= ': submatch(0)=~?"default" ? "endswitch" '
                              let b:endwise_addition .= ': submatch(0)=~?"repeat" ? "until <condition>" '
                              let b:endwise_addition .= ': submatch(0)=~#"\\u" ? "END" . toupper(submatch(0)) '
                              let b:endwise_addition .= ': "end" . tolower(submatch(0))'
                              let b:endwise_words     = 'def,deffct,defdat,then,while,for,repeat,case,default'
                              let b:endwise_pattern   = '^\s*\(\(global\s\+\)\?\zsdef\|\(global\s\+\)\?def\zs\(dat\|fct\)\|\zsif\|\zswhile\|\zsfor\|\zscase\|\zsdefault\|\zsrepeat\)\>\ze'
                              let b:endwise_syngroups = 'krlConditional,krlTypedef,krlRepeat'
    1              0.000001 endif
                            " }}} Endwise
                            
                            " Match It and Fold Text Object mapping {{{
                            
                            " matchit support
    1              0.000002 if exists("loaded_matchit") " depends on matchit (or matchup)
                              " ggf for, while etc aufsplitten
                              let b:match_words = '^\s*\<if\>\s[^;]\+\<then\>.*:^\s*\<else\>.*:^\s*\<endif\>.*,'
                                    \.'^\s*\<\(for\|while\|loop\|repeat\)\>.*:^\s*\<exit\>.*:^\s*\<\(end\(for\|while\|loop\)\|until\)\>.*,'
                                    \.'^\s*\<switch\>.*:^\s*\<case\>.*:^\s*\<default\>.*:^\s*\<endswitch\>.*,'
                                    \.'^\s*\(global\s\+\)\?\<def\(fct\)\?\>.*:^\s*\<resume\>.*:^\s*\<return\>.*:^\s*\<end\(fct\)\?\>.*,'
                                    \.'^\s*\<defdat\>.*:^\s*\<enddat\>.*,'
                                    \.'^\s*\<\(ptp_\)\?spline\>.*:^\s*\<endspline\>.*,'
                                    \.'^\s*\<skip\>.*:^\s*\<endskip\>.*,'
                                    \.'^\s*\<time_block\s\+start\>.*:^\s*\<time_block\s\+part\>.*:^\s*\<time_block\s\+end\>.*,'
                                    \.'^\s*\<const_vel\s\+start\>.*:^\s*\<const_vel\s\+end\>.*,'
                                    \.'\<fold\>:\<endfold\>'
                                    " \.'^\s*;\s*\<fold\>.*:^\s*;\s*\<endfold\>.*'    " doesn't work because of syntax item krlFoldComment
                              let b:match_ignorecase = 1 " KRL does ignore case
                              " matchit makes fold text objects easy
                              if get(g:,'krlFoldTextObject',0)
                                    \|| mapcheck("ao","x")=="" && !hasmapto('<plug>KrlTxtObjAroundFold','x')
                                xmap <silent><buffer> ao <plug>KrlTxtObjAroundFold
                              endif
                              if get(g:,'krlFoldTextObject',0)
                                    \|| mapcheck("io","x")=="" && !hasmapto('<plug>KrlTxtObjInnerFold','x')
                                xmap <silent><buffer> io <plug>KrlTxtObjInnerFold
                              endif
                              if get(g:,'krlFoldTextObject',0)
                                    \|| mapcheck("ao","o")=="" && !hasmapto('<plug>KrlTxtObjAroundFold','o')
                                omap <silent><buffer> ao <plug>KrlTxtObjAroundFold
                              endif
                              if get(g:,'krlFoldTextObject',0)
                                    \|| mapcheck("io","o")=="" && !hasmapto('<plug>KrlTxtObjInnerFold','o')
                                omap <silent><buffer> io <plug>KrlTxtObjInnerFold
                              endif
    1              0.000000 endif
                            
                            " }}} Match It and Fold Text Object mapping
                            
                            " Move Around and Function Text Object key mappings {{{
                            
    1              0.000003 if get(g:,'krlMoveAroundKeyMap',1)
                              " Move around functions
    1              0.000031   nnoremap <silent><buffer> [[ :<C-U>let b:knopCount=v:count1                     <Bar>call knop#NTimesSearch(b:knopCount, '\c\v^\s*(global\s+)?def(fct\|dat)?>'         , 'bs'  )<Bar>unlet b:knopCount<CR>:normal! zt<CR>
    1              0.000024   onoremap <silent><buffer> [[ :<C-U>let b:knopCount=v:count1                     <Bar>call knop#NTimesSearch(b:knopCount, '\c\v^\s*(global\s+)?def(fct\|dat)?>.*\n\zs'  , 'bsW' )<Bar>unlet b:knopCount<CR>
    1              0.000023   xnoremap <silent><buffer> [[ :<C-U>let b:knopCount=v:count1<Bar>exe "normal! gv"<Bar>call knop#NTimesSearch(b:knopCount, '\c\v^\s*(global\s+)?def(fct\|dat)?>'         , 'bsW' )<Bar>unlet b:knopCount<CR>
    1              0.000025   nnoremap <silent><buffer> ]] :<C-U>let b:knopCount=v:count1                     <Bar>call knop#NTimesSearch(b:knopCount, '\c\v^\s*(global\s+)?def(fct\|dat)?>'         , 's'   )<Bar>unlet b:knopCount<CR>:normal! zt<CR>
    1              0.000023   onoremap <silent><buffer> ]] :<C-U>let b:knopCount=v:count1                     <Bar>call knop#NTimesSearch(b:knopCount, '\c\v^\s*(global\s+)?def(fct\|dat)?>'         , 'sW'  )<Bar>unlet b:knopCount<CR>
    1              0.000023   xnoremap <silent><buffer> ]] :<C-U>let b:knopCount=v:count1<Bar>exe "normal! gv"<Bar>call knop#NTimesSearch(b:knopCount, '\c\v^\s*(global\s+)?def(fct\|dat)?>.*\n'     , 'seWz')<Bar>unlet b:knopCount<CR>
    1              0.000024   nnoremap <silent><buffer> [] :<C-U>let b:knopCount=v:count1                     <Bar>call knop#NTimesSearch(b:knopCount, '\c\v^\s*end(fct\|dat)?>'                     , 'bs'  )<Bar>unlet b:knopCount<CR>:normal! zb<CR>
    1              0.000023   onoremap <silent><buffer> [] :<C-U>let b:knopCount=v:count1                     <Bar>call knop#NTimesSearch(b:knopCount, '\c\v^\s*end(fct\|dat)?>\n^(.\|\n)'           , 'bseW')<Bar>unlet b:knopCount<CR>
    1              0.000022   xnoremap <silent><buffer> [] :<C-U>let b:knopCount=v:count1<Bar>exe "normal! gv"<Bar>call knop#NTimesSearch(b:knopCount, '\c\v^\s*end(fct\|dat)?>'                     , 'bsW' )<Bar>unlet b:knopCount<CR>
    1              0.000026   nnoremap <silent><buffer> ][ :<C-U>let b:knopCount=v:count1                     <Bar>call knop#NTimesSearch(b:knopCount, '\c\v^\s*end(fct\|dat)?>'                     , 's'   )<Bar>unlet b:knopCount<CR>:normal! zb<CR>
    1              0.000023   onoremap <silent><buffer> ][ :<C-U>let b:knopCount=v:count1                     <Bar>call knop#NTimesSearch(b:knopCount, '\c\v\ze^\s*end(fct\|dat)?>'                  , 'sW'  )<Bar>unlet b:knopCount<CR>
    1              0.000022   xnoremap <silent><buffer> ][ :<C-U>let b:knopCount=v:count1<Bar>exe "normal! gv"<Bar>call knop#NTimesSearch(b:knopCount, '\c\v^\s*end(fct\|dat)?>(\n)?'                , 'seWz')<Bar>unlet b:knopCount<CR>
                              " Move around comments
    1              0.000028   nnoremap <silent><buffer> [; :<C-U>let b:knopCount=v:count1                     <Bar>call knop#NTimesSearch(b:knopCount, '\v(^\s*;.*\n)@<!(^\s*;)'                     , 'bs'  )<Bar>unlet b:knopCount<cr>
    1              0.000023   onoremap <silent><buffer> [; :<C-U>let b:knopCount=v:count1                     <Bar>call knop#NTimesSearch(b:knopCount, '\v(^\s*;.*\n)@<!(^\s*;)'                     , 'bsW' )<Bar>unlet b:knopCount<cr>
    1              0.000022   xnoremap <silent><buffer> [; :<C-U>let b:knopCount=v:count1<Bar>exe "normal! gv"<Bar>call knop#NTimesSearch(b:knopCount, '\v(^\s*;.*\n)@<!(^\s*;)'                     , 'bsW' )<Bar>unlet b:knopCount<cr>
    1              0.000023   nnoremap <silent><buffer> ]; :<C-U>let b:knopCount=v:count1                     <Bar>call knop#NTimesSearch(b:knopCount, '\v^\s*;.*\n\s*([^;\t ]\|$)'                  , 's'   )<Bar>unlet b:knopCount<cr>
    1              0.000023   onoremap <silent><buffer> ]; :<C-U>let b:knopCount=v:count1                     <Bar>call knop#NTimesSearch(b:knopCount, '\v^\s*;.*\n(\s*[^;\t ]\|$)'                  , 'seW' )<Bar>unlet b:knopCount<cr>
    1              0.000022   xnoremap <silent><buffer> ]; :<C-U>let b:knopCount=v:count1<Bar>exe "normal! gv"<Bar>call knop#NTimesSearch(b:knopCount, '\v^\s*;.*\n\ze\s*([^;\t ]\|$)'               , 'seW' )<Bar>unlet b:knopCount<cr>
                              " inner and around function text objects
    1              0.000021   if get(g:,'krlFunctionTextObject',0)
                                    \|| mapcheck("aF","x")=="" && !hasmapto('<plug>KrlTxtObjAroundFuncInclCo','x')
    1              0.000007     xmap <silent><buffer> aF <plug>KrlTxtObjAroundFuncInclCo
    1              0.000001   endif
    1              0.000012   if get(g:,'krlFunctionTextObject',0)
                                    \|| mapcheck("af","x")=="" && !hasmapto('<plug>KrlTxtObjAroundFuncExclCo','x')
    1              0.000005     xmap <silent><buffer> af <plug>KrlTxtObjAroundFuncExclCo
    1              0.000001   endif
    1              0.000010   if get(g:,'krlFunctionTextObject',0)
                                    \|| mapcheck("if","x")=="" && !hasmapto('<plug>KrlTxtObjInnerFunc','x')
    1              0.000005     xmap <silent><buffer> if <plug>KrlTxtObjInnerFunc
    1              0.000001   endif
    1              0.000011   if get(g:,'krlFunctionTextObject',0)
                                    \|| mapcheck("aF","o")=="" && !hasmapto('<plug>KrlTxtObjAroundFuncInclCo','o')
    1              0.000005     omap <silent><buffer> aF <plug>KrlTxtObjAroundFuncInclCo
    1              0.000001   endif
    1              0.000011   if get(g:,'krlFunctionTextObject',0)
                                    \|| mapcheck("af","o")=="" && !hasmapto('<plug>KrlTxtObjAroundFuncExclCo','o')
    1              0.000005     omap <silent><buffer> af <plug>KrlTxtObjAroundFuncExclCo
    1              0.000001   endif
    1              0.000010   if get(g:,'krlFunctionTextObject',0)
                                    \|| mapcheck("if","o")=="" && !hasmapto('<plug>KrlTxtObjInnerFunc','o')
    1              0.000004     omap <silent><buffer> if <plug>KrlTxtObjInnerFunc
    1              0.000001   endif
                              " inner and around comment text objects
    1              0.000010   if get(g:,'krlCommentTextObject',0)
                                    \|| mapcheck("ac","x")=="" && !hasmapto('<plug>KrlTxtObjAroundComment','x')
    1              0.000005     xmap <silent><buffer> ac <plug>KrlTxtObjAroundComment
    1              0.000001   endif
    1              0.000010   if get(g:,'krlCommentTextObject',0)
                                    \|| mapcheck("ic","x")=="" && !hasmapto('<plug>KrlTxtObjInnerComment','x')
    1              0.000005     xmap <silent><buffer> ic <plug>KrlTxtObjInnerComment
    1              0.000001   endif
    1              0.000012   if get(g:,'krlCommentTextObject',0)
                                    \|| mapcheck("ac","o")=="" && !hasmapto('<plug>KrlTxtObjAroundComment','o')
    1              0.000005     omap <silent><buffer> ac <plug>KrlTxtObjAroundComment
    1              0.000001   endif
    1              0.000010   if get(g:,'krlCommentTextObject',0)
                                    \|| mapcheck("ic","o")=="" && !hasmapto('<plug>KrlTxtObjInnerComment','o')
    1              0.000005     omap <silent><buffer> ic <plug>KrlTxtObjInnerComment
    1              0.000001   endif
    1              0.000001 endif
                            
                            " }}} Move Around and Function Text Object key mappings
                            
                            " Other configurable key mappings {{{
                            
                            " if the mapping does not exist and there is no plug-mapping just map it,
                            " otherwise look for the config variable
                            
    1              0.000003 if has("folding")
    1              0.000025   if get(g:,'krlFoldingKeyMap',0) 
                                    \|| mapcheck("<F2>","n")=="" && mapcheck("<F3>","n")=="" && mapcheck("<F4>","n")==""
                                    \&& !hasmapto('<plug>KrlCloseAllFolds','n') && !hasmapto('<plug>KrlCloseLessFolds','n') && !hasmapto('<plug>KrlCloseNoFolds','n')
                                " close all folds
    1              0.000005     nmap <silent><buffer> <F4> <plug>KrlCloseAllFolds
                                " close move folds
    1              0.000005     nmap <silent><buffer> <F3> <plug>KrlCloseLessFolds
                                " open all folds
    1              0.000004     nmap <silent><buffer> <F2> <plug>KrlCloseNoFolds
    1              0.000001   endif
    1              0.000001 endif
                            
                            " }}} Configurable mappings
                            
                            " <PLUG> mappings {{{
                            
                            " Function Text Object
    1              0.000002 if get(g:,'krlMoveAroundKeyMap',1) " depends on move around key mappings
    1              0.000010   xnoremap <silent><buffer> <plug>KrlTxtObjAroundFuncInclCo :<C-U>call krl#FunctionTextObject(0,1)<CR>
    1              0.000009   xnoremap <silent><buffer> <plug>KrlTxtObjAroundFuncExclCo :<C-U>call krl#FunctionTextObject(0,0)<CR>
    1              0.000015   xnoremap <silent><buffer> <plug>KrlTxtObjInnerFunc        :<C-U>call krl#FunctionTextObject(1,0)<CR>
    1              0.000010   onoremap <silent><buffer> <plug>KrlTxtObjAroundFuncInclCo :<C-U>call krl#FunctionTextObject(0,1)<CR>
    1              0.000009   onoremap <silent><buffer> <plug>KrlTxtObjAroundFuncExclCo :<C-U>call krl#FunctionTextObject(0,0)<CR>
    1              0.000008   onoremap <silent><buffer> <plug>KrlTxtObjInnerFunc        :<C-U>call krl#FunctionTextObject(1,0)<CR>
    1              0.000001 endif
                            
                            " comment text objects
    1              0.000003 if get(g:,'krlMoveAroundKeyMap',1) " depends on move around key mappings
    1              0.000009   xnoremap <silent><buffer> <plug>KrlTxtObjAroundComment     :<C-U>call krl#CommentTextObject(1)<CR>
    1              0.000009   xnoremap <silent><buffer> <plug>KrlTxtObjInnerComment      :<C-U>call krl#CommentTextObject(0)<CR>
    1              0.000009   onoremap <silent><buffer> <plug>KrlTxtObjAroundComment     :<C-U>call krl#CommentTextObject(1)<CR>
    1              0.000008   onoremap <silent><buffer> <plug>KrlTxtObjInnerComment      :<C-U>call krl#CommentTextObject(0)<CR>
    1              0.000000 endif
                            
                            " folding
    1              0.000003 if has("folding")
    1              0.000013   if krl#IsVkrcFolgeOrUP()
                                nnoremap <silent><buffer> <plug>KrlCloseAllFolds  :setlocal foldlevel=0<CR>
                                nnoremap <silent><buffer> <plug>KrlCloseLessFolds :setlocal foldlevel=1<CR>
                                nnoremap <silent><buffer> <plug>KrlCloseNoFolds   :setlocal foldlevel=2<CR>
    1              0.000001   else
    1              0.000010     nnoremap <silent><buffer> <plug>KrlCloseAllFolds  :setlocal foldexpr=krl#FoldExpr(v:lnum,2)<CR>
    1              0.000009     nnoremap <silent><buffer> <plug>KrlCloseLessFolds :setlocal foldexpr=krl#FoldExpr(v:lnum,1)<CR>
    1              0.000009     nnoremap <silent><buffer> <plug>KrlCloseNoFolds   :setlocal foldexpr=krl#FoldExpr(v:lnum,0)<CR>
    1              0.000001   endif
    1              0.000000 endif
                            
                            " fold text objects
    1              0.000002 if exists("loaded_matchit") " depends on matchit (or matchup)
                              xnoremap <silent><buffer> <plug>KrlTxtObjAroundFold     :<C-U>call krl#FoldTextObject(0)<CR>
                              xnoremap <silent><buffer> <plug>KrlTxtObjInnerFold      :<C-U>call krl#FoldTextObject(1)<CR>
                              onoremap <silent><buffer> <plug>KrlTxtObjAroundFold     :<C-U>call krl#FoldTextObject(0)<CR>
                              onoremap <silent><buffer> <plug>KrlTxtObjInnerFold      :<C-U>call krl#FoldTextObject(1)<CR>
    1              0.000000 endif
                            
                            " }}} <plug> mappings
                            
                            " Finish {{{
    1              0.000006 let &cpo = s:keepcpo
    1              0.000002 unlet s:keepcpo
                            " }}} Finish
                            
                            " vim:sw=2 sts=2 et fdm=marker

SCRIPT  d:\daten\scripts\git\knop-01\krl-for-vim9\autoload\krl.vim
Sourced 1 time
Total time:   0.000249
 Self time:   0.000249

count  total (s)   self (s)
                            " Vim autoload file
                            " Language: Kuka Robot Language
                            " Maintainer: Patrick Meiser-Knosowski <knosowski@graeffrobotics.de>
                            " Version: 3.0.0
                            " Last Change: 20. Apr 2022
                            
                            " Init {{{
    1              0.000005 if exists("g:loaded_krl")
                              finish
    1              0.000001 endif
    1              0.000003 let g:loaded_krl = 1
                            
    1              0.000004 let s:keepcpo = &cpo
    1              0.000004 set cpo&vim
                            " }}} Init 
                            
                            " VKRC {{{
    1              0.000002 function krl#IsVkrc() abort
                              if exists("b:krlIsVkrc")
                                return b:krlIsVkrc
                              endif
                              if bufname("%") =~? '\v(folge|up|makro(saw|sps|step|trigger)?)\d*\.src'
                                for l:s in range(1, 8)
                                  if getline(l:s) =~? '\v^\s*\&param\s+tpvw_version>'
                                    let b:krlIsVkrc = 1
                                    return 1
                                  endif
                                endfor
                              endif
                              let b:krlIsVkrc = 0
                              return 0
                            endfunction
                            
    1              0.000002 function krl#IsVkrcFolgeOrUP() abort
                              return krl#IsVkrc() && bufname("%") =~? '\v%(folge|up)\d+\.src$'
                            endfunction
                            " }}} VKRC
                            
                            " Folding {{{
    1              0.000002 function krl#FoldText() abort
                              return substitute( substitute( getline(v:foldstart), '\v\c%(;\s*FOLD>\s+|;[^;]*$)', '', 'g'), '\(.*\)', '\1 -----', 'g')
                            endfunction
                            
    1              0.000003 function s:FoldLevelFirstLine(line, patternFold) abort
                              if a:line =~? a:patternFold
                                return 1
                              endif
                              return 0
                            endfunction
                            
    1              0.000002 function s:FoldLevel(do, lnum, returnLiteral) abort
                            
                              let foldLevelPrevLine = foldlevel(a:lnum - 1)
                              if  foldLevelPrevLine < 0 || a:returnLiteral
                                return a:do
                              endif
                            
                              let foldLevelChange = 0
                              if     a:do == "a1"
                                let foldLevelChange = 1
                              elseif a:do == "s1"
                                let foldLevelChange = (-1)
                              endif
                            
                              return foldLevelPrevLine + foldLevelChange
                            endfunction
                            
    1              0.000003 function s:Return_S1_OnMoveEndFold(lnum, patternAnyFold, patternMoveFold, patternEndFold) abort
                            
                              let foundEndfold = 1
                            
                              " look backwards to find matching fold
                              for i in reverse(range(1, a:lnum-1))
                            
                                if getline(i) =~? a:patternEndFold
                                  let foundEndfold += 1
                                endif
                            
                                if getline(i) =~? a:patternAnyFold 
                                  let foundEndfold -=1
                                endif
                            
                                if foundEndfold == 0
                                  if getline(i) =~? a:patternMoveFold
                                    " Return "s1" for movement fold.
                                    " Always return literal "s1" for any kind of endfold
                                    return "s1"
                                  endif
                                  break
                                endif
                            
                              endfor
                            
                              " return = for any other fold
                              let dontReturnLiteral = v:false
                              return s:FoldLevel("=", a:lnum, dontReturnLiteral)
                            endfunction
                            
    1              0.000002 function krl#FoldExpr(lnum, krlFoldLevel) abort
                            
                              if a:lnum < 1 || a:lnum > line("$") || a:krlFoldLevel == 0
                                return 0
                              endif
                            
                              let patternAnyFold  = '\v^\s*;\s*FOLD>'
                              let patternMoveFold = '\v^\s*;\s*FOLD>.*<%(S?%(LIN|PTP|CIRC)%(_REL)?|Parameters)>'
                              let patternEndFold  = '\v^\s*;\s*ENDFOLD>'
                              let line = getline(a:lnum)
                              if a:lnum > 1
                                " we are not in line 1, look for previous line as well
                                let prevLine = getline(a:lnum - 1)
                              endif
                              let returnLiteral = (prevLine =~? patternAnyFold || prevLine =~? patternEndFold)
                            
                              if krl#IsVkrc() || a:krlFoldLevel == 2
                            
                                if a:lnum == 1
                                  return s:FoldLevelFirstLine(line, patternAnyFold)
                                endif
                            
                                if line =~? patternAnyFold
                                  return s:FoldLevel("a1", a:lnum, returnLiteral)
                                endif
                            
                                if line =~? patternEndFold 
                                  " Always return literal "s1" for any kind of endfold
                                  return "s1"
                                endif
                            
                              elseif a:krlFoldLevel == 1
                            
                                if a:lnum == 1
                                  return s:FoldLevelFirstLine(line, patternMoveFold)
                                endif
                            
                                if line =~? patternMoveFold
                                  return s:FoldLevel("a1", a:lnum, returnLiteral)
                                endif
                            
                                if line =~? patternEndFold
                                  return s:Return_S1_OnMoveEndFold(a:lnum, patternAnyFold, patternMoveFold, patternEndFold)
                                endif
                            
                              endif
                            
                              return s:FoldLevel("=", a:lnum, returnLiteral)
                            endfunction
                            " }}} Folding
                            
                            " Function Text Object {{{
    1              0.000004 if get(g:, 'krlMoveAroundKeyMap', 1) " depends on move around key mappings
    1              0.000002   function krl#FunctionTextObject(inner,withcomment) abort
                                if a:inner==1
                                  let l:n = 1
                                else
                                  let l:n = v:count1
                                endif
                                if getline('.')!~'\v\c^\s*end(fct|dat)?>'
                                  silent normal ][
                                endif
                                silent normal [[
                                silent normal! zz
                                if a:inner==1
                                  silent normal! j
                                elseif a:withcomment==1
                                  while line('.')>1 && getline(line('.')-1)=~'\v\c^\s*;(\s*(end)?fold)@!'
                                    silent normal! k
                                  endwhile
                                endif
                                exec "silent normal V".l:n."]["
                                if a:inner==1
                                  silent normal! k
                                elseif a:withcomment==1 && getline(line('.')+1)=~'^\s*$'
                                  silent normal! j
                                endif
                              endfunction
    1              0.000001 endif
                            " }}} Function Text Object
                            
                            " Comment Text Object {{{
    1              0.000003 if get(g:, 'krlMoveAroundKeyMap', 1) " depends on move around key mappings
    1              0.000002   function krl#CommentTextObject(around) abort
                                if getline('.')!~'^\s*;' && !search('^\s*;',"sW")
                                  return
                                endif
                                " starte innerhalb des oder nach dem kommentar
                                silent normal! j
                                silent normal [;
                                silent normal! V
                                if getline(line('.')+1) =~ '^\s*;'
                                  silent normal ];
                                endif
                                if a:around && getline(line('.')+1)=~'^\s*$'
                                  silent normal! j
                                endif
                              endfunction
    1              0.000001 endif
                            " }}} Comment Text Object
                            
                            " Fold Text Object {{{
    1              0.000003 if exists("loaded_matchit") " depends on matchit (or matchup)
                              function krl#FoldTextObject(inner) abort
                                let l:col = col('.')
                                let l:line = line('.')
                                let l:foundFold = 0
                                let l:nEndfolds = v:count1
                                if getline('.')=~'\c^\s*;\s*fold\>'
                                      \&& l:nEndfolds>1
                                  " starte innerhalb des fold
                                  silent normal! j
                                endif
                                if getline('.')!~'\c^\s*;\s*fold\>' || l:nEndfolds>1 && search('\c^\s*;\s*fold\>','bnW')
                                  while l:foundFold==0 && line('.')>1 && search('\c^\s*;\s*fold\>','bcnW')
                                    silent normal! k
                                    if getline(line('.'))=~'\c^\s*;\s*endfold\>'
                                      let l:nEndfolds+=1
                                    endif
                                    if getline(line('.'))=~'\c^\s*;\s*fold\>'
                                      let l:nEndfolds-=1
                                      if l:nEndfolds==0
                                        let foundFold=1
                                      endif
                                    endif
                                  endwhile
                                else
                                  let l:foundFold=1
                                endif
                                if l:foundFold==1
                                  silent normal 0V%
                                  if a:inner == 1
                                    silent normal! k
                                    " ggf fold oeffnen der innerhalb des fold ist dessen inhalt geloescht werden soll 
                                    silent! normal! zo
                                    normal! '<
                                    silent normal 0V%
                                    " eigentlich will ich an der stelle nur <esc> druecken um die visual
                                    " selection wieder abzubrechen, aber das funktioniert irgendwie
                                    " nicht, also dieser hack
                                    silent normal! :<C-U><CR>
                                    silent normal! j
                                    silent normal! V
                                    silent normal! '>
                                    silent normal! k
                                  endif
                                else
                                  call cursor(l:line,l:col)
                                endif
                              endfunction
    1              0.000001 endif
                            " }}} Fold Text Object
                            
                            " Finish {{{
    1              0.000006 let &cpo = s:keepcpo
    1              0.000002 unlet s:keepcpo
                            " }}} Finish
                            
                            " vim:sw=2 sts=2 et fdm=marker

SCRIPT  d:\daten\scripts\git\knop-01\krl-for-vim9\indent\krl.vim
Sourced 1 time
Total time:   0.000191
 Self time:   0.000191

count  total (s)   self (s)
                            " Vim indent file
                            " Language: Kuka Robot Language
                            " Maintainer: Patrick Meiser-Knosowski <knosowski@graeffrobotics.de>
                            " Version: 3.0.0
                            " Last Change: 15. Apr 2022
                            " Credits: Based on indent/vim.vim
                            
                            " Only load this indent file when no other was loaded.
    1              0.000006 if exists("b:did_indent")
                              finish
    1              0.000001 endif
    1              0.000003 let b:did_indent = 1
                            
    1              0.000010 setlocal nolisp
    1              0.000001 setlocal nocindent
    1              0.000001 setlocal nosmartindent
    1              0.000001 setlocal autoindent
    1              0.000003 setlocal indentexpr=GetKrlIndent()
    1              0.000003 setlocal indentkeys=!^F,o,O,=~end,0=~else,0=~case,0=~default,0=~until,0=~continue,=~part
    1              0.000002 let b:undo_indent = "setlocal lisp< cindent< smartindent< autoindent< indentexpr< indentkeys<"
                            
    1              0.000003 if get(g:,'krlSpaceIndent',1)
                              " Use spaces, not tabs, for indention, 2 is enough. 
                              " More or even tabs would waste valuable space on the teach pendant.
    1              0.000002   setlocal softtabstop=2
    1              0.000001   setlocal shiftwidth=2
    1              0.000001   setlocal expandtab
    1              0.000001   setlocal shiftround
    1              0.000003   let b:undo_indent = b:undo_indent." softtabstop< shiftwidth< expandtab< shiftround<"
    1              0.000001 endif
                            
                            " Only define the function once.
    1              0.000003 if exists("*GetKrlIndent")
                              finish
    1              0.000001 endif
    1              0.000004 let s:keepcpo = &cpo
    1              0.000003 set cpo&vim
                            
    1              0.000002 function GetKrlIndent() abort
                            
                              let currentLine = getline(v:lnum)
                              if  currentLine =~? '\v^;(\s*(end)?fold>)@!' && !get(g:, 'krlCommentIndent', 0)
                                " If current line has a ; in column 1 and is no fold, keep zero indent.
                                " This may be usefull if code is commented out at the first column.
                                return 0
                              endif
                            
                              " Find a non-blank line above the current line.
                              let preNoneBlankLineNum = s:KrlPreNoneBlank(v:lnum - 1)
                              if  preNoneBlankLineNum == 0
                                " At the start of the file use zero indent.
                                return 0
                              endif
                            
                              let preNoneBlankLine = getline(preNoneBlankLineNum)
                              let ind = indent(preNoneBlankLineNum)
                            
                              " Define add 'shiftwidth' pattern
                              let addShiftwidthPattern =           '\v^\s*('
                              if get(g:, 'krlIndentBetweenDef', 1)
                                let addShiftwidthPattern ..=               '(global\s+)?def(fct|dat)?\s+\$?\w'
                                let addShiftwidthPattern ..=               '|'
                              endif
                              let addShiftwidthPattern   ..=               'if>|while>|for>|loop>'
                              let addShiftwidthPattern   ..=               '|else>'
                              let addShiftwidthPattern   ..=               '|case>|default>'
                              let addShiftwidthPattern   ..=               '|repeat>'
                              let addShiftwidthPattern   ..=               '|skip>|(ptp_)?spline>'
                              let addShiftwidthPattern   ..=               '|time_block\s+(start|part)>'
                              let addShiftwidthPattern   ..=               '|const_vel\s+start>'
                              let addShiftwidthPattern   ..=             ')'
                            
                              " Define Subtract 'shiftwidth' pattern
                              let subtractShiftwidthPattern =      '\v^\s*('
                              if get(g:, 'krlIndentBetweenDef', 1)
                                let subtractShiftwidthPattern ..=          'end(fct|dat)?>'
                                let subtractShiftwidthPattern ..=          '|'
                              endif
                              let subtractShiftwidthPattern   ..=          'end(if|while|for|loop)>'
                              let subtractShiftwidthPattern   ..=          '|else>'
                              let subtractShiftwidthPattern   ..=          '|case>|default>|endswitch>'
                              let subtractShiftwidthPattern   ..=          '|until>'
                              let subtractShiftwidthPattern   ..=          '|end(skip|spline)>'
                              let subtractShiftwidthPattern   ..=          '|time_block\s+(part|end)>'
                              let subtractShiftwidthPattern   ..=          '|const_vel\s+end>'
                              let subtractShiftwidthPattern   ..=        ')'
                            
                              " Add shiftwidth
                              if preNoneBlankLine =~? addShiftwidthPattern
                                let ind += &sw
                              endif
                            
                              " Subtract shiftwidth
                              if currentLine =~? subtractShiftwidthPattern
                                let ind = ind - &sw
                              endif
                            
                              " First case after a switch gets the indent of the switch.
                              if currentLine =~? '\v^\s*case>'  
                                    \&& preNoneBlankLine =~? '\v^\s*switch>'
                                let ind = ind + &sw
                              endif
                            
                              " align continue with the following instruction
                              if currentLine =~? '\v^\s*continue>'  
                                    \&& getline(v:lnum + 1) =~? subtractShiftwidthPattern
                                let ind = ind - &sw
                              endif
                            
                              return ind
                            endfunction
                            
                            " This function works almost like prevnonblank() but handles &-headers,
                            " comments and continue instructions like blank lines
    1              0.000003 function s:KrlPreNoneBlank(lnum) abort
                            
                              let nPreNoneBlank = prevnonblank(a:lnum)
                            
                              while nPreNoneBlank > 0 && getline(nPreNoneBlank) =~? '\v^\s*(\&\w\+|;|continue>)'
                                " Previouse none blank line irrelevant. Look further aback.
                                let nPreNoneBlank = prevnonblank(nPreNoneBlank - 1)
                              endwhile
                            
                              return nPreNoneBlank
                            endfunction
                            
    1              0.000007 let &cpo = s:keepcpo
    1              0.000002 unlet s:keepcpo
                            
                            " vim:sw=2 sts=2 et

SCRIPT  c:\Program Files (x86)\Vim\vim82\indent\krl.vim
Sourced 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
                            " Vim indent file
                            " Language: Kuka Robot Language
                            " Maintainer: Patrick Meiser-Knosowski <knosowski@graeffrobotics.de>
                            " Version: 3.0.0
                            " Last Change: 15. Apr 2022
                            " Credits: Based on indent/vim.vim
                            
                            " Only load this indent file when no other was loaded.
    1              0.000006 if exists("b:did_indent")
    1              0.000001   finish
                            endif
                            let b:did_indent = 1
                            
                            setlocal nolisp
                            setlocal nocindent
                            setlocal nosmartindent
                            setlocal autoindent
                            setlocal indentexpr=GetKrlIndent()
                            setlocal indentkeys=!^F,o,O,=~end,0=~else,0=~case,0=~default,0=~until,0=~continue,=~part
                            let b:undo_indent = "setlocal lisp< cindent< smartindent< autoindent< indentexpr< indentkeys<"
                            
                            if get(g:,'krlSpaceIndent',1)
                              " Use spaces, not tabs, for indention, 2 is enough. 
                              " More or even tabs would waste valuable space on the teach pendant.
                              setlocal softtabstop=2
                              setlocal shiftwidth=2
                              setlocal expandtab
                              setlocal shiftround
                              let b:undo_indent = b:undo_indent." softtabstop< shiftwidth< expandtab< shiftround<"
                            endif
                            
                            " Only define the function once.
                            if exists("*GetKrlIndent")
                              finish
                            endif
                            let s:keepcpo = &cpo
                            set cpo&vim
                            
                            function GetKrlIndent() abort
                            
                              let currentLine = getline(v:lnum)
                              if  currentLine =~? '\v^;(\s*(end)?fold>)@!' && !get(g:, 'krlCommentIndent', 0)
                                " If current line has a ; in column 1 and is no fold, keep zero indent.
                                " This may be usefull if code is commented out at the first column.
                                return 0
                              endif
                            
                              " Find a non-blank line above the current line.
                              let preNoneBlankLineNum = s:KrlPreNoneBlank(v:lnum - 1)
                              if  preNoneBlankLineNum == 0
                                " At the start of the file use zero indent.
                                return 0
                              endif
                            
                              let preNoneBlankLine = getline(preNoneBlankLineNum)
                              let ind = indent(preNoneBlankLineNum)
                            
                              " Define add 'shiftwidth' pattern
                              let addShiftwidthPattern =           '\v^\s*('
                              if get(g:, 'krlIndentBetweenDef', 1)
                                let addShiftwidthPattern ..=               '(global\s+)?def(fct|dat)?\s+\$?\w'
                                let addShiftwidthPattern ..=               '|'
                              endif
                              let addShiftwidthPattern   ..=               'if>|while>|for>|loop>'
                              let addShiftwidthPattern   ..=               '|else>'
                              let addShiftwidthPattern   ..=               '|case>|default>'
                              let addShiftwidthPattern   ..=               '|repeat>'
                              let addShiftwidthPattern   ..=               '|skip>|(ptp_)?spline>'
                              let addShiftwidthPattern   ..=               '|time_block\s+(start|part)>'
                              let addShiftwidthPattern   ..=               '|const_vel\s+start>'
                              let addShiftwidthPattern   ..=             ')'
                            
                              " Define Subtract 'shiftwidth' pattern
                              let subtractShiftwidthPattern =      '\v^\s*('
                              if get(g:, 'krlIndentBetweenDef', 1)
                                let subtractShiftwidthPattern ..=          'end(fct|dat)?>'
                                let subtractShiftwidthPattern ..=          '|'
                              endif
                              let subtractShiftwidthPattern   ..=          'end(if|while|for|loop)>'
                              let subtractShiftwidthPattern   ..=          '|else>'
                              let subtractShiftwidthPattern   ..=          '|case>|default>|endswitch>'
                              let subtractShiftwidthPattern   ..=          '|until>'
                              let subtractShiftwidthPattern   ..=          '|end(skip|spline)>'
                              let subtractShiftwidthPattern   ..=          '|time_block\s+(part|end)>'
                              let subtractShiftwidthPattern   ..=          '|const_vel\s+end>'
                              let subtractShiftwidthPattern   ..=        ')'
                            
                              " Add shiftwidth
                              if preNoneBlankLine =~? addShiftwidthPattern
                                let ind += &sw
                              endif
                            
                              " Subtract shiftwidth
                              if currentLine =~? subtractShiftwidthPattern
                                let ind = ind - &sw
                              endif
                            
                              " First case after a switch gets the indent of the switch.
                              if currentLine =~? '\v^\s*case>'  
                                    \&& preNoneBlankLine =~? '\v^\s*switch>'
                                let ind = ind + &sw
                              endif
                            
                              " align continue with the following instruction
                              if currentLine =~? '\v^\s*continue>'  
                                    \&& getline(v:lnum + 1) =~? subtractShiftwidthPattern
                                let ind = ind - &sw
                              endif
                            
                              return ind
                            endfunction
                            
                            " This function works almost like prevnonblank() but handles &-headers,
                            " comments and continue instructions like blank lines
                            function s:KrlPreNoneBlank(lnum) abort
                            
                              let nPreNoneBlank = prevnonblank(a:lnum)
                            
                              while nPreNoneBlank > 0 && getline(nPreNoneBlank) =~? '\v^\s*(\&\w\+|;|continue>)'
                                " Previouse none blank line irrelevant. Look further aback.
                                let nPreNoneBlank = prevnonblank(nPreNoneBlank - 1)
                              endwhile
                            
                              return nPreNoneBlank
                            endfunction
                            
                            let &cpo = s:keepcpo
                            unlet s:keepcpo
                            
                            " vim:sw=2 sts=2 et

FUNCTION  krl#IsVkrc()
    Defined: d:\daten\scripts\git\knop-01\krl-for-vim9\autoload\krl.vim:18
Called 28743 times
Total time:   0.088066
 Self time:   0.088066

count  total (s)   self (s)
28743              0.051164   if exists("b:krlIsVkrc")
28742              0.027009     return b:krlIsVkrc
    1              0.000001   endif
    1              0.000023   if bufname("%") =~? '\v(folge|up|makro(saw|sps|step|trigger)?)\d*\.src'
                                for l:s in range(1, 8)
                                  if getline(l:s) =~? '\v^\s*\&param\s+tpvw_version>'
                                    let b:krlIsVkrc = 1
                                    return 1
                                  endif
                                endfor
    1              0.000001   endif
    1              0.000002   let b:krlIsVkrc = 0
    1              0.000001   return 0

FUNCTION  krl#FoldExpr()
    Defined: d:\daten\scripts\git\knop-01\krl-for-vim9\autoload\krl.vim:99
Called 28741 times
Total time:   1.836189
 Self time:   1.506027

count  total (s)   self (s)
                            
28741              0.073155   if a:lnum < 1 || a:lnum > line("$") || a:krlFoldLevel == 0
                                return 0
28741              0.013601   endif
                            
28741              0.039371   let patternAnyFold  = '\v^\s*;\s*FOLD>'
28741              0.044846   let patternMoveFold = '\v^\s*;\s*FOLD>.*<%(S?%(LIN|PTP|CIRC)%(_REL)?|Parameters)>'
28741              0.035583   let patternEndFold  = '\v^\s*;\s*ENDFOLD>'
28741              0.053537   let line = getline(a:lnum)
28741              0.025209   if a:lnum > 1
                                " we are not in line 1, look for previous line as well
28721              0.055917     let prevLine = getline(a:lnum - 1)
28741              0.014481   endif
28741              0.185384   let returnLiteral = (prevLine =~? patternAnyFold || prevLine =~? patternEndFold)
                            
28741   0.156154   0.068141   if krl#IsVkrc() || a:krlFoldLevel == 2
                            
28741              0.025055     if a:lnum == 1
   20   0.000188   0.000072       return s:FoldLevelFirstLine(line, patternAnyFold)
28721              0.014021     endif
                            
28721              0.088226     if line =~? patternAnyFold
 2889   0.026125   0.009240       return s:FoldLevel("a1", a:lnum, returnLiteral)
25832              0.011688     endif
                            
25832              0.083680     if line =~? patternEndFold 
                                  " Always return literal "s1" for any kind of endfold
 2891              0.002387       return "s1"
22941              0.009960     endif
                            
                              elseif a:krlFoldLevel == 1
                            
                                if a:lnum == 1
                                  return s:FoldLevelFirstLine(line, patternMoveFold)
                                endif
                            
                                if line =~? patternMoveFold
                                  return s:FoldLevel("a1", a:lnum, returnLiteral)
                                endif
                            
                                if line =~? patternEndFold
                                  return s:Return_S1_OnMoveEndFold(a:lnum, patternAnyFold, patternMoveFold, patternEndFold)
                                endif
                            
22941              0.009897   endif
                            
22941   0.295341   0.070192   return s:FoldLevel("=", a:lnum, returnLiteral)

FUNCTION  krl#IsVkrcFolgeOrUP()
    Defined: d:\daten\scripts\git\knop-01\krl-for-vim9\autoload\krl.vim:34
Called 2 times
Total time:   0.000070
 Self time:   0.000017

count  total (s)   self (s)
    2   0.000069   0.000016   return krl#IsVkrc() && bufname("%") =~? '\v%(folge|up)\d+\.src$'

FUNCTION  <SNR>19_KrlPreNoneBlank()
    Defined: d:\daten\scripts\git\knop-01\krl-for-vim9\indent\krl.vim:115
Called 2 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
                            
    2              0.000008   let nPreNoneBlank = prevnonblank(a:lnum)
                            
    2              0.000022   while nPreNoneBlank > 0 && getline(nPreNoneBlank) =~? '\v^\s*(\&\w\+|;|continue>)'
                                " Previouse none blank line irrelevant. Look further aback.
                                let nPreNoneBlank = prevnonblank(nPreNoneBlank - 1)
    2              0.000002   endwhile
                            
    2              0.000002   return nPreNoneBlank

FUNCTION  <SNR>18_Return_S1_OnMoveEndFold()
    Defined: d:\daten\scripts\git\knop-01\krl-for-vim9\autoload\krl.vim:68
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            
                              let foundEndfold = 1
                            
                              " look backwards to find matching fold
                              for i in reverse(range(1, a:lnum-1))
                            
                                if getline(i) =~? a:patternEndFold
                                  let foundEndfold += 1
                                endif
                            
                                if getline(i) =~? a:patternAnyFold 
                                  let foundEndfold -=1
                                endif
                            
                                if foundEndfold == 0
                                  if getline(i) =~? a:patternMoveFold
                                    " Return "s1" for movement fold.
                                    " Always return literal "s1" for any kind of endfold
                                    return "s1"
                                  endif
                                  break
                                endif
                            
                              endfor
                            
                              " return = for any other fold
                              let dontReturnLiteral = v:false
                              return s:FoldLevel("=", a:lnum, dontReturnLiteral)

FUNCTION  krl#FunctionTextObject()
    Defined: d:\daten\scripts\git\knop-01\krl-for-vim9\autoload\krl.vim:152
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if a:inner==1
                                  let l:n = 1
                                else
                                  let l:n = v:count1
                                endif
                                if getline('.')!~'\v\c^\s*end(fct|dat)?>'
                                  silent normal ][
                                endif
                                silent normal [[
                                silent normal! zz
                                if a:inner==1
                                  silent normal! j
                                elseif a:withcomment==1
                                  while line('.')>1 && getline(line('.')-1)=~'\v\c^\s*;(\s*(end)?fold)@!'
                                    silent normal! k
                                  endwhile
                                endif
                                exec "silent normal V".l:n."]["
                                if a:inner==1
                                  silent normal! k
                                elseif a:withcomment==1 && getline(line('.')+1)=~'^\s*$'
                                  silent normal! j
                                endif

FUNCTION  <SNR>18_FoldLevelFirstLine()
    Defined: d:\daten\scripts\git\knop-01\krl-for-vim9\autoload\krl.vim:44
Called 20 times
Total time:   0.000116
 Self time:   0.000116

count  total (s)   self (s)
   20              0.000083   if a:line =~? a:patternFold
   12              0.000009     return 1
    8              0.000004   endif
    8              0.000005   return 0

FUNCTION  GetKrlIndent()
    Defined: d:\daten\scripts\git\knop-01\krl-for-vim9\indent\krl.vim:39
Called 3 times
Total time:   0.000225
 Self time:   0.000183

count  total (s)   self (s)
                            
    3              0.000007   let currentLine = getline(v:lnum)
    3              0.000031   if  currentLine =~? '\v^;(\s*(end)?fold>)@!' && !get(g:, 'krlCommentIndent', 0)
                                " If current line has a ; in column 1 and is no fold, keep zero indent.
                                " This may be usefull if code is commented out at the first column.
    1              0.000001     return 0
    2              0.000001   endif
                            
                              " Find a non-blank line above the current line.
    2   0.000051   0.000008   let preNoneBlankLineNum = s:KrlPreNoneBlank(v:lnum - 1)
    2              0.000002   if  preNoneBlankLineNum == 0
                                " At the start of the file use zero indent.
    1              0.000001     return 0
    1              0.000000   endif
                            
    1              0.000002   let preNoneBlankLine = getline(preNoneBlankLineNum)
    1              0.000002   let ind = indent(preNoneBlankLineNum)
                            
                              " Define add 'shiftwidth' pattern
    1              0.000002   let addShiftwidthPattern =           '\v^\s*('
    1              0.000003   if get(g:, 'krlIndentBetweenDef', 1)
    1              0.000003     let addShiftwidthPattern ..=               '(global\s+)?def(fct|dat)?\s+\$?\w'
    1              0.000002     let addShiftwidthPattern ..=               '|'
    1              0.000000   endif
    1              0.000002   let addShiftwidthPattern   ..=               'if>|while>|for>|loop>'
    1              0.000002   let addShiftwidthPattern   ..=               '|else>'
    1              0.000002   let addShiftwidthPattern   ..=               '|case>|default>'
    1              0.000002   let addShiftwidthPattern   ..=               '|repeat>'
    1              0.000002   let addShiftwidthPattern   ..=               '|skip>|(ptp_)?spline>'
    1              0.000002   let addShiftwidthPattern   ..=               '|time_block\s+(start|part)>'
    1              0.000002   let addShiftwidthPattern   ..=               '|const_vel\s+start>'
    1              0.000002   let addShiftwidthPattern   ..=             ')'
                            
                              " Define Subtract 'shiftwidth' pattern
    1              0.000002   let subtractShiftwidthPattern =      '\v^\s*('
    1              0.000002   if get(g:, 'krlIndentBetweenDef', 1)
    1              0.000002     let subtractShiftwidthPattern ..=          'end(fct|dat)?>'
    1              0.000002     let subtractShiftwidthPattern ..=          '|'
    1              0.000000   endif
    1              0.000002   let subtractShiftwidthPattern   ..=          'end(if|while|for|loop)>'
    1              0.000002   let subtractShiftwidthPattern   ..=          '|else>'
    1              0.000002   let subtractShiftwidthPattern   ..=          '|case>|default>|endswitch>'
    1              0.000002   let subtractShiftwidthPattern   ..=          '|until>'
    1              0.000002   let subtractShiftwidthPattern   ..=          '|end(skip|spline)>'
    1              0.000002   let subtractShiftwidthPattern   ..=          '|time_block\s+(part|end)>'
    1              0.000002   let subtractShiftwidthPattern   ..=          '|const_vel\s+end>'
    1              0.000003   let subtractShiftwidthPattern   ..=        ')'
                            
                              " Add shiftwidth
    1              0.000026   if preNoneBlankLine =~? addShiftwidthPattern
                                let ind += &sw
    1              0.000000   endif
                            
                              " Subtract shiftwidth
    1              0.000015   if currentLine =~? subtractShiftwidthPattern
                                let ind = ind - &sw
    1              0.000000   endif
                            
                              " First case after a switch gets the indent of the switch.
    1              0.000005   if currentLine =~? '\v^\s*case>'  && preNoneBlankLine =~? '\v^\s*switch>'
                                let ind = ind + &sw
    1              0.000000   endif
                            
                              " align continue with the following instruction
    1              0.000005   if currentLine =~? '\v^\s*continue>'  && getline(v:lnum + 1) =~? subtractShiftwidthPattern
                                let ind = ind - &sw
    1              0.000000   endif
                            
    1              0.000001   return ind

FUNCTION  <SNR>18_FoldLevel()
    Defined: d:\daten\scripts\git\knop-01\krl-for-vim9\autoload\krl.vim:51
Called 25830 times
Total time:   0.242033
 Self time:   0.242033

count  total (s)   self (s)
                            
25830              0.059712   let foldLevelPrevLine = foldlevel(a:lnum - 1)
25830              0.036706   if  foldLevelPrevLine < 0 || a:returnLiteral
13326              0.012176     return a:do
12504              0.005632   endif
                            
12504              0.014517   let foldLevelChange = 0
12504              0.013884   if     a:do == "a1"
  194              0.000218     let foldLevelChange = 1
12310              0.013085   elseif a:do == "s1"
                                let foldLevelChange = (-1)
12504              0.005520   endif
                            
12504              0.015992   return foldLevelPrevLine + foldLevelChange

FUNCTION  krl#FoldText()
    Defined: d:\daten\scripts\git\knop-01\krl-for-vim9\autoload\krl.vim:40
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return substitute( substitute( getline(v:foldstart), '\v\c%(;\s*FOLD>\s+|;[^;]*$)', '', 'g'), '\(.*\)', '\1 -----', 'g')

FUNCTION  krl#CommentTextObject()
    Defined: d:\daten\scripts\git\knop-01\krl-for-vim9\autoload\krl.vim:182
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if getline('.')!~'^\s*;' && !search('^\s*;',"sW")
                                  return
                                endif
                                " starte innerhalb des oder nach dem kommentar
                                silent normal! j
                                silent normal [;
                                silent normal! V
                                if getline(line('.')+1) =~ '^\s*;'
                                  silent normal ];
                                endif
                                if a:around && getline(line('.')+1)=~'^\s*$'
                                  silent normal! j
                                endif

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
28741   1.836189   1.506027  krl#FoldExpr()
25830   0.242033             <SNR>18_FoldLevel()
28743   0.088066             krl#IsVkrc()
    3   0.000225   0.000183  GetKrlIndent()
   20   0.000116             <SNR>18_FoldLevelFirstLine()
    2   0.000070   0.000017  krl#IsVkrcFolgeOrUP()
    2   0.000043             <SNR>19_KrlPreNoneBlank()
                             <SNR>18_Return_S1_OnMoveEndFold()
                             krl#FunctionTextObject()
                             krl#FoldText()
                             krl#CommentTextObject()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
28741   1.836189   1.506027  krl#FoldExpr()
25830              0.242033  <SNR>18_FoldLevel()
28743              0.088066  krl#IsVkrc()
    3   0.000225   0.000183  GetKrlIndent()
   20              0.000116  <SNR>18_FoldLevelFirstLine()
    2              0.000043  <SNR>19_KrlPreNoneBlank()
    2   0.000070   0.000017  krl#IsVkrcFolgeOrUP()
                             krl#FunctionTextObject()
                             krl#FoldText()
                             krl#CommentTextObject()
                             <SNR>18_Return_S1_OnMoveEndFold()

